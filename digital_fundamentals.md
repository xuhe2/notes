# 1-1



analog 模拟

digital 电子



DAC : digital to analog converter

> in a mixed system



# 1-2

1. use votage level
2. use current level



> bit : one binary digit



clock:时钟:同步不同的元器件



pulse: 脉冲

pulse width:脉宽:从上升边的50%到下降边的50%的距离



rising edge : 从0到1的上升边

falling edge : 从1到0的下降边



rising time : 从10%到90%的上升需要的时间

falling time



占空比（Duty Cycle）是一个在电子技术中经常使用的概念，通常用于描述周期性信号（如脉冲信号或方波信号）中的高电平（或开启状态）与总周期之间的比例。占空比通常用百分比表示，它告诉我们信号在一个周期内处于高电平状态的时间与整个周期的比例。

占空比的计算公式如下：


$$
\text{占空比} (\%) = \frac{\text{高电平时间}}{\text{总周期时间}} \times 100\%
$$


其中：

- 高电平时间：信号处于高电平状态（逻辑“1”或通常是正电压）的持续时间。
- 总周期时间：一个完整的周期所需要的时间。

举例来说，如果有一个方波信号，周期为1秒，其中高电平时间为0.2秒，那么占空比为：
$$
[ \text{占空比} = \frac{0.2\, \text{秒}}{1\, \text{秒}} \times 100\% = 20\% ]
$$




这表示在这个信号中，高电平占了总周期的20%。

占空比在电子电路中非常重要，因为它可以影响信号的平均功率、频率响应以及电路的性能。在控制电路、PWM（脉宽调制）调光、电机驱动、信号传输等应用中，占空比的设置和调整都扮演着关键的角色。







数据传输

1. serial transform单传递,一次只传送一个1bit
2. parallel transform并发传输,一次传递多个



# 2 



## 2-1

radix/base : 进制

carry : 进位



## 2-5



1. 反码（Ones' Complement）：
   - 反码是一种用于表示有符号整数的编码方式。
   - 在反码中，正数的二进制表示与其绝对值的二进制表示相同，即符号位为0。
   - 负数的反码表示方法是将其绝对值的二进制表示中的每一位取反（0变为1，1变为0），同时保留符号位为1表示负数。
   - 反码的缺点是有两个零表示：+0和-0。
2. 补码（Two's Complement）：
   - 补码也是一种用于表示有符号整数的编码方式，是最广泛使用的有符号整数表示方法。
   - 在补码中，正数的二进制表示与其绝对值的二进制表示相同，即符号位为0。
   - 负数的补码表示方法是将其绝对值的二进制表示中的每一位取反（0变为1，1变为0），然后再加1，同时保留符号位为1表示负数。
   - 补码的优点是只有一个零表示：0，而且它可以更自然地支持加法和减法操作，因为减法可以通过加法来实现。



* 其实,计算单元只有加法器



* 注意,需要体现出进制的位数.



## BCD`binary coded decimal`

> 本质是十进制数
>
> 所以不可能出现1010-1111
>
> 当你需要使用`BCD`编码表示13这样的时候,他是和16进制的表示方式是不同的.



## `gray`code

表达的位数依次提升的时候,每次变化的位数只有一位.

* 防止一次一次变化的时候,造成数据传输的问题.

* 可以实现和2进制数值额相互转换.



* is a unweighted code



# parity method

mas奇偶校验

> 传输的代码中,1的个数是奇数:奇校验
>
> 同理,偶校验

* 同来纠错的





# 逻辑门

## inverter

> 取反



## and gate

> A&B使用`AB`,或者中间加个点来表示.



mask:屏蔽字

> 可以使用`and`运算符来只保留我自己想要的几个位置的01值,其他位置的全部变成0
>
> 用来保留模板串中是1的位置的01值.



## or gate

> 使用`A+B`表示



* 也可以做`mask`操作



## NAND gate

与非门



* 可以用`NAND gate`表示全部的门



## NOR gate



anode : 阳极

阴极 : catnode





## XOR gate

异或门

> 表示符号:圆圈里面是叉叉



## XNOR gate

同或运算符

只有在AB输入相同的时候,才是1

> 圆圈里面加上点.

* 对于比较器有用.



# rules

1. commutative law 交换律
2. assocative law 结合律
3. distributive law 分配律



## 布尔代数

A+AB = A

> 可以使用`venn diagram`证明

* 书本P102



# SOP/POS

sum of product : 乘积和

product of sum 



转换为标准变量的样子

> 在每一项中都需要出现全部的变量名



* 任意两个最小项的积一定是0
* 全部最小项的和一定是1
* 每两个相邻的最小项相加,可以约去一个因子

* 最大项和最小项是相互取反的,所以,最小项是and起来,最大项是or起来



# 卡诺图

使用方格图表示所有情况的图

> 用来化简逻辑函数



> 图的边上是枚举部分元素的情况
>
> 图的格子里面填的0/1



卡诺圈（Karnaugh Map，简称K-Map）是用于简化布尔函数的逻辑图形工具中的一种重要概念。卡诺圈用于在卡诺图中标记一组相邻的1方格，以便更容易地识别并简化布尔函数。

以下是有关卡诺圈的重要信息：

1. **卡诺图回顾**：卡诺圈通常用于卡诺图中，而卡诺图是一个用于可视化布尔函数的二进制输入组合的矩阵。每个方格代表一个输入组合，而1方格表示函数在该输入组合下的输出值为1。

2. **卡诺圈的形状**：卡诺圈通常由相邻的1方格组成，并形成一个矩形或正方形。卡诺圈的边缘必须与卡诺图的方格边界平行，不能倾斜。

3. **卡诺圈的目的**：卡诺圈的主要目的是将布尔函数中的最小项分组在卡诺图中，以便更容易地识别和简化这些最小项。分组的最小项可以合并成更简单的布尔表达式，从而减少逻辑门的数量和电路的复杂性。

4. **合并相邻的最小项**：卡诺圈可以用来合并相邻的最小项，这些最小项具有相同的输入变量。通常，一个卡诺圈内的最小项都有相同数量的输入变量，而且只有一个输入变量的不同。合并这些最小项将减少布尔函数中的项数。

5. **卡诺圈的规则**：卡诺圈的规则包括：
   - 卡诺圈必须是2的幂次方大小，例如，2x2、4x4、8x8等。
   - 卡诺圈不能重叠，也不能包含不相邻的方格。
   - 卡诺圈可以沿着卡诺图的边缘延伸。

通过使用卡诺圈，工程师可以更轻松地进行布尔函数的最小化，提高电路的效率，并减少逻辑门的数量。这对于数字电子电路的设计和优化非常重要。



> 边角的元素和另一个边的元素可以构成卡诺圈
>
> 其实,构成卡诺圈的元素是相邻的,也就代表这些相邻元素之间只有一个0/1符号位不一样
>
> 谁变了就不要谁,只写下不变的部分
>
> 圈起来的时候需要圈起来最大的部分.

* 注意,所有的格子都要圈起来(哪怕只有他自己)



* 使用`d`表示的是无关项.可以是0也可以是1,在卡诺图中,用`X`表示(合理使用可以方便化简)

> 注意,无关项使用约束条件来表示,比如`BC = 0`(表示方式),代表所有可以使用`BC`表示的项都是无关项.
>
> * 使用约束条件,可以使得圈(可能)更大.



# 逻辑电路

logic circuit

分成

> 1. combinational 和时间无关
> 2. sequential 时序(和时间有关)



# 组合电路(combinational)



## and-or

> 使用与门和或门



当var and their complements are available,我们可以直接获得取反的时候,我们不需要考虑非门.



注意

* 与非门和非或门(negative-or)是一样的
* 同理,或非门和非与门(negative-and)是一样的



## 画电路的时候

你需要合理使用SOP和POS



注意,合理使用卡诺图可以实现电路尽可能的少使用零件.



SSI : small scale intergation 1-10

MSI 10-100

LSI 100-1000

VLSI : very large 1000-10000



## 型号

54LS138

> 第一个参数`数字`,有54/74两种
>
> 1. 54军用
> 2. 74民用
>
> 第二个参数是使用TTL/CMOS
>
> 1. LS TTL
> 2. HC CMOS



> 注意,TTL是高功耗和高速,可以空着放输入脚
>
> 注意,CMOS不可以空着输入脚,因为空的时候是默认1



## half-adder(半加器)

半加器（Half Adder）是一种基本的数字电路，用于执行二进制数的加法操作。它可以将两个单独的二进制位相加，并生成两个输出：一个是和（Sum），另一个是进位（Carry）。

半加器有两个输入位：A和B，分别代表要相加的两个二进制位。它有两个输出位：Sum（和）和Carry（进位）：

1. **和位（Sum）**：Sum位表示A和B的二进制位相加的结果。它是通过异或门（XOR gate）计算得出的，其真值表如下：

   ```
   | A | B | Sum |
   |---|---|-----|
   | 0 | 0 |  0  |
   | 0 | 1 |  1  |
   | 1 | 0 |  1  |
   | 1 | 1 |  0  |
   ```

2. **进位位（Carry）**：Carry位表示A和B的二进制位相加时是否产生进位（进位到高位）。它是通过与门（AND gate）计算得出的，其真值表如下：

   ```
   | A | B | Carry |
   |---|---|-------|
   | 0 | 0 |   0   |
   | 0 | 1 |   0   |
   | 1 | 0 |   0   |
   | 1 | 1 |   1   |
   ```

半加器非常简单，用于处理两个单独的二进制位相加。但需要注意的是，半加器只能处理当前位的进位情况，不能处理来自更高位的进位。对于多位二进制数相加，通常需要使用全加器（Full Adder）或其他更高级的加法器。

半加器是数字电路设计的基本组成部分，用于构建更复杂的数字逻辑电路和算术运算电路。


$$
C_{out} = carry~out 进位的部分
$$


## full adder

> 可以使用半加器获得全加器



注意

* **C_{out}** 是与门
* 个位数的数字计算是异或门



## parallel binary adder

可以通过连接**full adder**实现



> 同一级别的位置数相加,从小一位的位置加法那边拿进位数字相加
>
> 由此可以获得多个位数的二进制数相加



> **乘法**实现,使用移位操作,错位接上去
>
> 把需要乘起来的数字用二进制表示,然后看1的位置开始移位.



> 实现`相等`的操作符,可以使用同或门逐一比较



## COMP比较器

74LS85

使用同或运算符



> 从高位到低位进行比较
>
> 当A=B的时候,结果由`cascading input`(级联输入,级联输入也是三个,和结果的意义一样)决定



> 获得的结果是三个
>
> 1. A>B
> 2. A<B
> 3. A=B



例如

使用两个比较4位的二进制数字的电路组合比较8位的二进制数字

第一个比较器的位权重应该是低一点的

把第一个比较器的结果传给第二个比较器的级联输入(cascading input)

